<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 为什么var会挂载在windows中,let就不会
        // 代码本质? 文本字符串  编辑器  
        // 交给chrome的js编译器 v8引擎
        // 分词 var name  =  字符串数据类型
        // 在内存之中声明空间
        // 编译阶段  语法校验  name用let的话进入暂时性死区
        // 运行阶段  
        // 内存中声明
        // 两个name是不同的对象
        // VO{global: , name}
        // 变量查找按作用域查找
        // console.log(name);//undefined 变量提升 
        // var name = "windowsName";  //window global scope
        // var y = 5;
        // function a(){
        //     var x = 2;
        //     // VO{function: , name}
        //     var name = "Cherry";  // function scope
        //     console.log(name);
        //     console.log(x,y);
        // }
        // a(); // 一段代码 内存中 进入执行栈 当前运行的叫AO{function:name chain: Global VO}
        // 'use strict';
        var name = "windowsName";
        var a = {
            name:"Cherry",
            fn:function(){
                console.log(this.name);
            }
        }
        // function a(){
        //     // this  不会指向作用域 只会指向调用他的对象
        //     var name = "Cherry";
        //     // 无法确定 this的值由调用的方式决定 
        //     console.log(this.name);  
        // }
        a.fn();// 函数一定会变量提升  提升到window  window.a 而严格模式下是undefined
        window.a.fn();
        var f = a.fn;// 赋值 函数对象 f 指向 引用式赋值
        f();  // window.f
    </script>
</body>
</html>